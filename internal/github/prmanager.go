package github

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/8tcapital/ai-dep-manager/internal/ai"
)

// PRManager handles comprehensive pull request management and automation
type PRManager struct {
	client           *Client
	aiManager        ai.AIManager
	descriptionGen   *PRDescriptionGenerator
	testingIntegrator *TestingIntegrator
	reviewManager    *ReviewManager
	statusTracker    *PRStatusTracker
	conflictDetector *MergeConflictDetector
}

// NewPRManager creates a new PR manager
func NewPRManager(client *Client, aiManager *ai.Manager) *PRManager {
	return &PRManager{
		client:           client,
		aiManager:        aiManager,
		descriptionGen:   NewPRDescriptionGenerator(aiManager),
		testingIntegrator: NewTestingIntegrator(client),
		reviewManager:    NewReviewManager(client, aiManager),
		statusTracker:    NewPRStatusTracker(client),
		conflictDetector: NewMergeConflictDetector(client),
	}
}

// PRCreationRequest represents a request to create a pull request
type PRCreationRequest struct {
	Repository      string                 `json:"repository"`
	BaseBranch      string                 `json:"base_branch"`
	HeadBranch      string                 `json:"head_branch"`
	Title           string                 `json:"title"`
	Patches         []*Patch              `json:"patches"`
	Dependencies    []*DependencyUpdate   `json:"dependencies"`
	Options         *PRCreationOptions    `json:"options"`
	Context         map[string]interface{} `json:"context"`
}

// PRCreationOptions configures PR creation behavior
type PRCreationOptions struct {
	AutoGenerateDescription bool                    `json:"auto_generate_description"`
	EnableTestingIntegration bool                   `json:"enable_testing_integration"`
	RequestReviews          bool                    `json:"request_reviews"`
	AutoMergeEnabled        bool                    `json:"auto_merge_enabled"`
	Labels                  []string               `json:"labels"`
	Assignees               []string               `json:"assignees"`
	Reviewers               []string               `json:"reviewers"`
	TeamReviewers           []string               `json:"team_reviewers"`
	Milestone               string                 `json:"milestone"`
	Priority                PRPriority             `json:"priority"`
	NotificationSettings    *NotificationSettings  `json:"notification_settings"`
}

// PRPriority defines the priority level of a pull request
type PRPriority string

const (
	PriorityLow      PRPriority = "low"
	PriorityMedium   PRPriority = "medium"
	PriorityHigh     PRPriority = "high"
	PriorityCritical PRPriority = "critical"
)

// NotificationSettings configures PR notifications
type NotificationSettings struct {
	NotifyOnCreate     bool     `json:"notify_on_create"`
	NotifyOnUpdate     bool     `json:"notify_on_update"`
	NotifyOnMerge      bool     `json:"notify_on_merge"`
	NotifyOnConflict   bool     `json:"notify_on_conflict"`
	NotifyOnFailure    bool     `json:"notify_on_failure"`
	SlackChannels      []string `json:"slack_channels"`
	EmailRecipients    []string `json:"email_recipients"`
	WebhookURLs        []string `json:"webhook_urls"`
}

// PRResult represents the result of PR creation and management
type PRResult struct {
	PullRequest      *PullRequest           `json:"pull_request"`
	Description      *PRDescription         `json:"description"`
	TestingResults   []*TestingResult       `json:"testing_results"`
	ReviewRequests   []*ReviewRequest       `json:"review_requests"`
	StatusUpdates    []*StatusUpdate        `json:"status_updates"`
	ConflictAnalysis *ConflictAnalysis      `json:"conflict_analysis"`
	Recommendations  []*PRRecommendation    `json:"recommendations"`
	Success          bool                   `json:"success"`
	Errors           []string               `json:"errors"`
}

// PullRequest is now defined in shared_types.go

// PRDescription represents a generated pull request description
type PRDescription struct {
	Summary         string                 `json:"summary"`
	Changes         []*ChangeDescription   `json:"changes"`
	Dependencies    []*DependencyChange    `json:"dependencies"`
	RiskAssessment  *RiskAssessment        `json:"risk_assessment"`
	TestingNotes    string                 `json:"testing_notes"`
	ReviewGuidance  string                 `json:"review_guidance"`
	BreakingChanges []*BreakingChange      `json:"breaking_changes"`
	Checklist       []string               `json:"checklist"`
	Metadata        map[string]interface{} `json:"metadata"`
}

// ChangeDescription describes a specific change in the PR
type ChangeDescription struct {
	Type        string  `json:"type"`        // "feature", "bugfix", "refactor", "dependency"
	File        string  `json:"file"`
	Description string  `json:"description"`
	Impact      string  `json:"impact"`
	Confidence  float64 `json:"confidence"`
}

// DependencyChange describes a dependency change
type DependencyChange struct {
	Name           string  `json:"name"`
	CurrentVersion string  `json:"current_version"`
	NewVersion     string  `json:"new_version"`
	ChangeType     string  `json:"change_type"` // "major", "minor", "patch"
	RiskLevel      string  `json:"risk_level"`
	Justification  string  `json:"justification"`
}

type RiskFactor struct {
	Type        string  `json:"type"`
	Description string  `json:"description"`
	Severity    string  `json:"severity"`
	Likelihood  string  `json:"likelihood"`
	Impact      string  `json:"impact"`
}

// CreatePullRequest creates a comprehensive pull request with all automation
func (prm *PRManager) CreatePullRequest(ctx context.Context, request *PRCreationRequest) (*PRResult, error) {
	result := &PRResult{
		TestingResults:  []*TestingResult{},
		ReviewRequests:  []*ReviewRequest{},
		StatusUpdates:   []*StatusUpdate{},
		Recommendations: []*PRRecommendation{},
		Errors:          []string{},
	}

	// Generate PR description if requested
	if request.Options.AutoGenerateDescription {
		description, err := prm.descriptionGen.GenerateDescription(ctx, request)
		if err != nil {
			result.Errors = append(result.Errors, fmt.Sprintf("Failed to generate description: %v", err))
		} else {
			result.Description = description
		}
	}

	// Create the pull request
	pr, err := prm.createPullRequest(request, result.Description)
	if err != nil {
		return result, fmt.Errorf("failed to create pull request: %w", err)
	}
	result.PullRequest = pr

	// Setup testing integration if enabled
	if request.Options.EnableTestingIntegration {
		testingResults, err := prm.testingIntegrator.SetupTesting(ctx, pr, request.Patches)
		if err != nil {
			result.Errors = append(result.Errors, fmt.Sprintf("Failed to setup testing: %v", err))
		} else {
			result.TestingResults = testingResults
		}
	}

	// Request reviews if enabled
	if request.Options.RequestReviews {
		reviewRequests, err := prm.reviewManager.RequestReviews(ctx, pr, request.Options)
		if err != nil {
			result.Errors = append(result.Errors, fmt.Sprintf("Failed to request reviews: %v", err))
		} else {
			result.ReviewRequests = reviewRequests
		}
	}

	// Analyze merge conflicts
	conflictAnalysis, err := prm.conflictDetector.AnalyzeConflicts(ctx, pr)
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to analyze conflicts: %v", err))
	} else {
		result.ConflictAnalysis = conflictAnalysis
	}

	// Generate recommendations
	result.Recommendations = prm.generateRecommendations(result)

	result.Success = len(result.Errors) == 0
	return result, nil
}

// createPullRequest creates the actual GitHub pull request
func (prm *PRManager) createPullRequest(request *PRCreationRequest, description *PRDescription) (*PullRequest, error) {
	// Build PR body from description
	body := ""
	if description != nil {
		body = prm.buildPRBody(description)
	}

	// Create PR via GitHub API (simplified)
	pr := &PullRequest{
		ID:         12345, // Would be returned from GitHub API
		Number:     42,    // Would be returned from GitHub API
		Title:      request.Title,
		Body:       body,
		State:      "open",
		URL:        fmt.Sprintf("https://github.com/%s/pull/42", request.Repository),
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
		BaseBranch: request.BaseBranch,
		HeadBranch: request.HeadBranch,
		Labels:     request.Options.Labels,
		Assignees:  request.Options.Assignees,
		Reviewers:  request.Options.Reviewers,
		Milestone:  request.Options.Milestone,
	}

	return pr, nil
}

// buildPRBody builds the PR body from the description
func (prm *PRManager) buildPRBody(description *PRDescription) string {
	var body strings.Builder

	// Summary
	body.WriteString("## Summary\n\n")
	body.WriteString(description.Summary)
	body.WriteString("\n\n")

	// Changes
	if len(description.Changes) > 0 {
		body.WriteString("## Changes\n\n")
		for _, change := range description.Changes {
			body.WriteString(fmt.Sprintf("- **%s** (%s): %s\n", change.File, change.Type, change.Description))
		}
		body.WriteString("\n")
	}

	// Dependencies
	if len(description.Dependencies) > 0 {
		body.WriteString("## Dependency Updates\n\n")
		for _, dep := range description.Dependencies {
			body.WriteString(fmt.Sprintf("- **%s**: %s → %s (%s, %s risk)\n", 
				dep.Name, dep.CurrentVersion, dep.NewVersion, dep.ChangeType, dep.RiskLevel))
		}
		body.WriteString("\n")
	}

	// Breaking Changes
	if len(description.BreakingChanges) > 0 {
		body.WriteString("## ⚠️ Breaking Changes\n\n")
		for _, bc := range description.BreakingChanges {
			body.WriteString(fmt.Sprintf("- **%s**: %s\n", bc.Type, bc.Description))
			if bc.Migration != "" {
				body.WriteString(fmt.Sprintf("  - Migration: %s\n", bc.Migration))
			}
		}
		body.WriteString("\n")
	}

	// Risk Assessment
	if description.RiskAssessment != nil {
		body.WriteString("## Risk Assessment\n\n")
		body.WriteString(fmt.Sprintf("**Overall Risk**: %s\n\n", description.RiskAssessment.OverallRisk))
		
		if len(description.RiskAssessment.RiskFactors) > 0 {
			body.WriteString("**Risk Factors**:\n")
			for _, rf := range description.RiskAssessment.RiskFactors {
				body.WriteString(fmt.Sprintf("- %s (%s): %s\n", rf.Type, rf.Severity, rf.Description))
			}
			body.WriteString("\n")
		}
		
		if len(description.RiskAssessment.Mitigations) > 0 {
			body.WriteString("**Mitigations**:\n")
			for _, mitigation := range description.RiskAssessment.Mitigations {
				body.WriteString(fmt.Sprintf("- %s\n", mitigation))
			}
			body.WriteString("\n")
		}
	}

	// Testing Notes
	if description.TestingNotes != "" {
		body.WriteString("## Testing\n\n")
		body.WriteString(description.TestingNotes)
		body.WriteString("\n\n")
	}

	// Review Guidance
	if description.ReviewGuidance != "" {
		body.WriteString("## Review Guidance\n\n")
		body.WriteString(description.ReviewGuidance)
		body.WriteString("\n\n")
	}

	// Checklist
	if len(description.Checklist) > 0 {
		body.WriteString("## Checklist\n\n")
		for _, item := range description.Checklist {
			body.WriteString(fmt.Sprintf("- [ ] %s\n", item))
		}
		body.WriteString("\n")
	}

	return body.String()
}

// UpdatePullRequest updates an existing pull request
func (prm *PRManager) UpdatePullRequest(ctx context.Context, pr *PullRequest, updates *PRUpdateRequest) (*PRResult, error) {
	result := &PRResult{
		PullRequest:     pr,
		StatusUpdates:   []*StatusUpdate{},
		Recommendations: []*PRRecommendation{},
		Errors:          []string{},
	}

	// Update PR fields
	if updates.Title != "" {
		pr.Title = updates.Title
	}
	if updates.Body != "" {
		pr.Body = updates.Body
	}
	if len(updates.Labels) > 0 {
		pr.Labels = updates.Labels
	}

	// Track status update
	statusUpdate := &StatusUpdate{
		Type:        "pr_updated",
		Description: "Pull request updated",
		Timestamp:   time.Now(),
		Details:     updates.UpdateReason,
	}
	result.StatusUpdates = append(result.StatusUpdates, statusUpdate)

	result.Success = true
	return result, nil
}

// MonitorPullRequest monitors a pull request for status changes
func (prm *PRManager) MonitorPullRequest(ctx context.Context, pr *PullRequest) (*PRMonitoringResult, error) {
	return prm.statusTracker.MonitorPR(ctx, pr)
}

// generateRecommendations generates recommendations based on PR analysis
func (prm *PRManager) generateRecommendations(result *PRResult) []*PRRecommendation {
	var recommendations []*PRRecommendation

	// Recommend additional testing if high risk
	if result.Description != nil && result.Description.RiskAssessment != nil {
		if result.Description.RiskAssessment.OverallRisk == "high" || result.Description.RiskAssessment.OverallRisk == "critical" {
			recommendations = append(recommendations, &PRRecommendation{
				Type:        "testing",
				Priority:    "high",
				Description: "Consider additional testing due to high risk assessment",
				Action:      "add_comprehensive_tests",
				Confidence:  0.9,
			})
		}
	}

	// Recommend additional reviewers for breaking changes
	if result.Description != nil && len(result.Description.BreakingChanges) > 0 {
		recommendations = append(recommendations, &PRRecommendation{
			Type:        "review",
			Priority:    "high",
			Description: "Request additional reviewers due to breaking changes",
			Action:      "add_senior_reviewers",
			Confidence:  0.8,
		})
	}

	// Recommend conflict resolution if conflicts detected
	if result.ConflictAnalysis != nil && result.ConflictAnalysis.HasConflicts {
		recommendations = append(recommendations, &PRRecommendation{
			Type:        "conflict",
			Priority:    "critical",
			Description: "Resolve merge conflicts before proceeding",
			Action:      "resolve_conflicts",
			Confidence:  1.0,
		})
	}

	return recommendations
}

// PRUpdateRequest represents a request to update a pull request
type PRUpdateRequest struct {
	Title        string   `json:"title"`
	Body         string   `json:"body"`
	Labels       []string `json:"labels"`
	Assignees    []string `json:"assignees"`
	UpdateReason string   `json:"update_reason"`
}

// PRRecommendation represents a recommendation for PR management
type PRRecommendation struct {
	Type        string  `json:"type"`
	Priority    string  `json:"priority"`
	Description string  `json:"description"`
	Action      string  `json:"action"`
	Confidence  float64 `json:"confidence"`
}

// StatusUpdate represents a status update for a PR
type StatusUpdate struct {
	Type        string                 `json:"type"`
	Description string                 `json:"description"`
	Timestamp   time.Time              `json:"timestamp"`
	Details     string                 `json:"details"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// TestingResult represents the result of testing integration
type TestingResult struct {
	Type        string    `json:"type"`
	Status      string    `json:"status"`
	Description string    `json:"description"`
	URL         string    `json:"url"`
	StartedAt   time.Time `json:"started_at"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`
}

// ReviewRequest represents a review request
type ReviewRequest struct {
	Reviewer    string    `json:"reviewer"`
	Type        string    `json:"type"` // "user" or "team"
	Status      string    `json:"status"`
	RequestedAt time.Time `json:"requested_at"`
	Message     string    `json:"message"`
}

// ConflictAnalysis represents merge conflict analysis
type ConflictAnalysis struct {
	HasConflicts    bool              `json:"has_conflicts"`
	ConflictCount   int               `json:"conflict_count"`
	ConflictFiles   []string          `json:"conflict_files"`
	ConflictDetails []*ConflictDetail `json:"conflict_details"`
	Resolution      string            `json:"resolution"`
	Recommendations []string          `json:"recommendations"`
}

// ConflictDetail provides details about a specific conflict
type ConflictDetail struct {
	File        string `json:"file"`
	Line        int    `json:"line"`
	Type        string `json:"type"`
	Description string `json:"description"`
	Severity    string `json:"severity"`
}

// PRMonitoringResult represents the result of PR monitoring
type PRMonitoringResult struct {
	Status          string         `json:"status"`
	LastUpdated     time.Time      `json:"last_updated"`
	StatusChanges   []*StatusUpdate `json:"status_changes"`
	TestingStatus   string         `json:"testing_status"`
	ReviewStatus    string         `json:"review_status"`
	ConflictStatus  string         `json:"conflict_status"`
	ReadyToMerge    bool           `json:"ready_to_merge"`
	Notifications   []*Notification `json:"notifications"`
}

// Notification represents a notification about PR status
type Notification struct {
	Type        string                 `json:"type"`
	Message     string                 `json:"message"`
	Timestamp   time.Time              `json:"timestamp"`
	Recipients  []string               `json:"recipients"`
	Channels    []string               `json:"channels"`
	Metadata    map[string]interface{} `json:"metadata"`
}
