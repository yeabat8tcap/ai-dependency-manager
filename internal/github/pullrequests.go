package github

import (
	"context"
	"fmt"
	"strings"
	"time"
)

// PullRequestsService handles pull request-related GitHub API operations
type PullRequestsService struct {
	client *Client
}

// PullRequest is now defined in shared_types.go

// PullRequestBranch represents a branch in a pull request
type PullRequestBranch struct {
	Label string      `json:"label"`
	Ref   string      `json:"ref"`
	SHA   string      `json:"sha"`
	User  *User       `json:"user"`
	Repo  *Repository `json:"repo"`
}

// Label represents a GitHub label
type Label struct {
	ID          int64   `json:"id"`
	NodeID      string  `json:"node_id"`
	URL         string  `json:"url"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Color       string  `json:"color"`
	Default     bool    `json:"default"`
}

// Milestone represents a GitHub milestone
type Milestone struct {
	ID           int64      `json:"id"`
	NodeID       string     `json:"node_id"`
	Number       int        `json:"number"`
	State        string     `json:"state"`
	Title        string     `json:"title"`
	Description  *string    `json:"description"`
	Creator      *User      `json:"creator"`
	OpenIssues   int        `json:"open_issues"`
	ClosedIssues int        `json:"closed_issues"`
	CreatedAt    time.Time  `json:"created_at"`
	UpdatedAt    time.Time  `json:"updated_at"`
	ClosedAt     *time.Time `json:"closed_at"`
	DueOn        *time.Time `json:"due_on"`
	HTMLURL      string     `json:"html_url"`
	LabelsURL    string     `json:"labels_url"`
	URL          string     `json:"url"`
}

// AutoMerge represents auto-merge settings
type AutoMerge struct {
	EnabledBy     *User  `json:"enabled_by"`
	MergeMethod   string `json:"merge_method"`
	CommitTitle   string `json:"commit_title"`
	CommitMessage string `json:"commit_message"`
}

// PullRequestRequest represents a request to create or update a pull request
type PullRequestRequest struct {
	Title                 string   `json:"title"`
	Head                  string   `json:"head"`
	Base                  string   `json:"base"`
	Body                  *string  `json:"body,omitempty"`
	MaintainerCanModify   *bool    `json:"maintainer_can_modify,omitempty"`
	Draft                 *bool    `json:"draft,omitempty"`
	Issue                 *int     `json:"issue,omitempty"`
}

// PatchPullRequestConfig represents configuration for creating patch pull requests
type PatchPullRequestConfig struct {
	PackageName     string
	FromVersion     string
	ToVersion       string
	PatchType       string
	BreakingChanges []string
	SecurityFixes   []string
	Summary         string
	RiskLevel       string
	Confidence      float64
	FilesChanged    []string
	TestsIncluded   bool
	ReviewersNeeded []string
	Labels          []string
}

// GeneratePatchPRTitle generates a standardized title for patch pull requests
func GeneratePatchPRTitle(config *PatchPullRequestConfig) string {
	var prefix string
	switch config.PatchType {
	case "breaking":
		prefix = "🔥 BREAKING"
	case "security":
		prefix = "🔒 SECURITY"
	case "major":
		prefix = "📈 MAJOR"
	case "minor":
		prefix = "📦 MINOR"
	case "patch":
		prefix = "🔧 PATCH"
	default:
		prefix = "📦 UPDATE"
	}
	
	return fmt.Sprintf("%s: Update %s from %s to %s",
		prefix,
		config.PackageName,
		config.FromVersion,
		config.ToVersion,
	)
}

// GeneratePatchPRBody generates a comprehensive body for patch pull requests
func GeneratePatchPRBody(config *PatchPullRequestConfig) string {
	var body strings.Builder
	
	// Header
	body.WriteString("## 🤖 Automated Dependency Patch\n\n")
	body.WriteString("This pull request was automatically generated by the AI Dependency Manager to update a dependency with potential breaking changes.\n\n")
	
	// Package Information
	body.WriteString("### 📦 Package Information\n")
	body.WriteString(fmt.Sprintf("- **Package:** `%s`\n", config.PackageName))
	body.WriteString(fmt.Sprintf("- **From Version:** `%s`\n", config.FromVersion))
	body.WriteString(fmt.Sprintf("- **To Version:** `%s`\n", config.ToVersion))
	body.WriteString(fmt.Sprintf("- **Update Type:** %s\n", strings.Title(config.PatchType)))
	body.WriteString(fmt.Sprintf("- **Risk Level:** %s\n", strings.Title(config.RiskLevel)))
	body.WriteString(fmt.Sprintf("- **AI Confidence:** %.1f%%\n\n", config.Confidence*100))
	
	// Summary
	if config.Summary != "" {
		body.WriteString("### 📋 Summary\n")
		body.WriteString(config.Summary)
		body.WriteString("\n\n")
	}
	
	// Breaking Changes
	if len(config.BreakingChanges) > 0 {
		body.WriteString("### ⚠️ Breaking Changes\n")
		for _, change := range config.BreakingChanges {
			body.WriteString(fmt.Sprintf("- %s\n", change))
		}
		body.WriteString("\n")
	}
	
	// Security Fixes
	if len(config.SecurityFixes) > 0 {
		body.WriteString("### 🔒 Security Fixes\n")
		for _, fix := range config.SecurityFixes {
			body.WriteString(fmt.Sprintf("- %s\n", fix))
		}
		body.WriteString("\n")
	}
	
	// Files Changed
	if len(config.FilesChanged) > 0 {
		body.WriteString("### 📁 Files Modified\n")
		for _, file := range config.FilesChanged {
			body.WriteString(fmt.Sprintf("- `%s`\n", file))
		}
		body.WriteString("\n")
	}
	
	// Testing Information
	body.WriteString("### 🧪 Testing\n")
	if config.TestsIncluded {
		body.WriteString("- ✅ Automated tests have been updated and are passing\n")
	} else {
		body.WriteString("- ⚠️ Manual testing may be required\n")
	}
	body.WriteString("- 🤖 AI-generated patches have been applied\n")
	body.WriteString("- 📊 Code analysis completed with confidence scoring\n\n")
	
	// Review Instructions
	body.WriteString("### 👀 Review Instructions\n")
	body.WriteString("Please review the following before merging:\n")
	body.WriteString("1. **Functionality:** Ensure all features work as expected\n")
	body.WriteString("2. **Breaking Changes:** Verify that breaking changes are handled correctly\n")
	body.WriteString("3. **Tests:** Run the full test suite to ensure compatibility\n")
	body.WriteString("4. **Documentation:** Update documentation if necessary\n\n")
	
	// Footer
	body.WriteString("---\n")
	body.WriteString("*This pull request was created automatically by [AI Dependency Manager](https://github.com/8tcapital/ai-dep-manager). ")
	body.WriteString("If you have questions or concerns, please review the patch analysis and contact your development team.*")
	
	return body.String()
}

// Create creates a new pull request
func (p *PullRequestsService) Create(ctx context.Context, owner, repo string, pull *PullRequestRequest) (*PullRequest, error) {
	path := fmt.Sprintf("repos/%s/%s/pulls", owner, repo)
	
	req, err := p.client.NewRequest(ctx, "POST", path, pull)
	if err != nil {
		return nil, err
	}
	
	pr := new(PullRequest)
	_, err = p.client.Do(req, pr)
	if err != nil {
		return nil, err
	}
	
	return pr, nil
}

// CreatePatchPR creates a pull request for a dependency patch
func (p *PullRequestsService) CreatePatchPR(ctx context.Context, owner, repo, headBranch, baseBranch string, config *PatchPullRequestConfig) (*PullRequest, error) {
	title := GeneratePatchPRTitle(config)
	body := GeneratePatchPRBody(config)
	
	pullRequest := &PullRequestRequest{
		Title: title,
		Head:  headBranch,
		Base:  baseBranch,
		Body:  &body,
		Draft: &[]bool{config.RiskLevel == "high"}[0], // Create as draft if high risk
	}
	
	pr, err := p.Create(ctx, owner, repo, pullRequest)
	if err != nil {
		return nil, err
	}
	
	// Add labels if specified
	if len(config.Labels) > 0 {
		if err := p.AddLabels(ctx, owner, repo, pr.Number, config.Labels); err != nil {
			logger.Warn("Failed to add labels to PR #%d: %v", pr.Number, err)
		}
	}
	
	// Request reviewers if specified
	if len(config.ReviewersNeeded) > 0 {
		if err := p.RequestReviewers(ctx, owner, repo, pr.Number, config.ReviewersNeeded, nil); err != nil {
			logger.Warn("Failed to request reviewers for PR #%d: %v", pr.Number, err)
		}
	}
	
	return pr, nil
}

// Get retrieves a specific pull request
func (p *PullRequestsService) Get(ctx context.Context, owner, repo string, number int) (*PullRequest, error) {
	path := fmt.Sprintf("repos/%s/%s/pulls/%d", owner, repo, number)
	
	req, err := p.client.NewRequest(ctx, "GET", path, nil)
	if err != nil {
		return nil, err
	}
	
	pr := new(PullRequest)
	_, err = p.client.Do(req, pr)
	if err != nil {
		return nil, err
	}
	
	return pr, nil
}

// List lists pull requests for a repository
func (p *PullRequestsService) List(ctx context.Context, owner, repo string, opts *PullRequestListOptions) ([]*PullRequest, error) {
	path := fmt.Sprintf("repos/%s/%s/pulls", owner, repo)
	
	req, err := p.client.NewRequest(ctx, "GET", path, nil)
	if err != nil {
		return nil, err
	}
	
	// Add query parameters
	if opts != nil {
		q := req.URL.Query()
		if opts.State != "" {
			q.Add("state", opts.State)
		}
		if opts.Head != "" {
			q.Add("head", opts.Head)
		}
		if opts.Base != "" {
			q.Add("base", opts.Base)
		}
		if opts.Sort != "" {
			q.Add("sort", opts.Sort)
		}
		if opts.Direction != "" {
			q.Add("direction", opts.Direction)
		}
		if opts.PerPage > 0 {
			q.Add("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Page > 0 {
			q.Add("page", fmt.Sprintf("%d", opts.Page))
		}
		req.URL.RawQuery = q.Encode()
	}
	
	var prs []*PullRequest
	_, err = p.client.Do(req, &prs)
	if err != nil {
		return nil, err
	}
	
	return prs, nil
}

// PullRequestListOptions specifies options for listing pull requests
type PullRequestListOptions struct {
	State     string `url:"state,omitempty"`     // open, closed, all
	Head      string `url:"head,omitempty"`      // Filter by head branch
	Base      string `url:"base,omitempty"`      // Filter by base branch
	Sort      string `url:"sort,omitempty"`      // created, updated, popularity
	Direction string `url:"direction,omitempty"` // asc, desc
	PerPage   int    `url:"per_page,omitempty"`
	Page      int    `url:"page,omitempty"`
}

// Update updates a pull request
func (p *PullRequestsService) Update(ctx context.Context, owner, repo string, number int, pull *PullRequestRequest) (*PullRequest, error) {
	path := fmt.Sprintf("repos/%s/%s/pulls/%d", owner, repo, number)
	
	req, err := p.client.NewRequest(ctx, "PATCH", path, pull)
	if err != nil {
		return nil, err
	}
	
	pr := new(PullRequest)
	_, err = p.client.Do(req, pr)
	if err != nil {
		return nil, err
	}
	
	return pr, nil
}

// Close closes a pull request
func (p *PullRequestsService) Close(ctx context.Context, owner, repo string, number int) (*PullRequest, error) {
	pull := &PullRequestRequest{
		Title: "", // Will be ignored
		Head:  "", // Will be ignored
		Base:  "", // Will be ignored
	}
	
	// Note: GitHub API doesn't have a direct close endpoint, we update state through edit
	path := fmt.Sprintf("repos/%s/%s/pulls/%d", owner, repo, number)
	
	updateData := map[string]string{"state": "closed"}
	
	req, err := p.client.NewRequest(ctx, "PATCH", path, updateData)
	if err != nil {
		return nil, err
	}
	
	pr := new(PullRequest)
	_, err = p.client.Do(req, pr)
	if err != nil {
		return nil, err
	}
	
	return pr, nil
}

// Merge merges a pull request
func (p *PullRequestsService) Merge(ctx context.Context, owner, repo string, number int, opts *PullRequestMergeOptions) (*PullRequestMergeResult, error) {
	path := fmt.Sprintf("repos/%s/%s/pulls/%d/merge", owner, repo, number)
	
	req, err := p.client.NewRequest(ctx, "PUT", path, opts)
	if err != nil {
		return nil, err
	}
	
	result := new(PullRequestMergeResult)
	_, err = p.client.Do(req, result)
	if err != nil {
		return nil, err
	}
	
	return result, nil
}

// PullRequestMergeOptions specifies options for merging a pull request
type PullRequestMergeOptions struct {
	CommitTitle   string `json:"commit_title,omitempty"`
	CommitMessage string `json:"commit_message,omitempty"`
	SHA           string `json:"sha,omitempty"`
	MergeMethod   string `json:"merge_method,omitempty"` // merge, squash, rebase
}

// PullRequestMergeResult represents the result of merging a pull request
type PullRequestMergeResult struct {
	SHA     string `json:"sha"`
	Merged  bool   `json:"merged"`
	Message string `json:"message"`
}

// AddLabels adds labels to a pull request
func (p *PullRequestsService) AddLabels(ctx context.Context, owner, repo string, number int, labels []string) error {
	path := fmt.Sprintf("repos/%s/%s/issues/%d/labels", owner, repo, number)
	
	req, err := p.client.NewRequest(ctx, "POST", path, map[string][]string{"labels": labels})
	if err != nil {
		return err
	}
	
	_, err = p.client.Do(req, nil)
	return err
}

// RequestReviewers requests reviewers for a pull request
func (p *PullRequestsService) RequestReviewers(ctx context.Context, owner, repo string, number int, reviewers []string, teamReviewers []string) error {
	path := fmt.Sprintf("repos/%s/%s/pulls/%d/requested_reviewers", owner, repo, number)
	
	requestData := map[string][]string{}
	if len(reviewers) > 0 {
		requestData["reviewers"] = reviewers
	}
	if len(teamReviewers) > 0 {
		requestData["team_reviewers"] = teamReviewers
	}
	
	req, err := p.client.NewRequest(ctx, "POST", path, requestData)
	if err != nil {
		return err
	}
	
	_, err = p.client.Do(req, nil)
	return err
}

// ListPatchPRs lists all patch pull requests created by the AI Dependency Manager
func (p *PullRequestsService) ListPatchPRs(ctx context.Context, owner, repo string) ([]*PullRequest, error) {
	prs, err := p.List(ctx, owner, repo, &PullRequestListOptions{
		State: "all",
	})
	if err != nil {
		return nil, err
	}
	
	var patchPRs []*PullRequest
	for _, pr := range prs {
		// Check if PR was created by AI Dependency Manager
		if strings.Contains(pr.Title, "🤖") || 
		   strings.Contains(pr.Title, "BREAKING:") ||
		   strings.Contains(pr.Title, "SECURITY:") ||
		   strings.Contains(pr.Title, "UPDATE:") ||
		   (pr.Body != nil && strings.Contains(*pr.Body, "AI Dependency Manager")) {
			patchPRs = append(patchPRs, pr)
		}
	}
	
	return patchPRs, nil
}
